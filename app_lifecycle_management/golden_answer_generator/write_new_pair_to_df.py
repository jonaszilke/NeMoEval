# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

import os
import pandas as pd
import json

df = pd.DataFrame()


# For each prompt, please specify the returned type you want.
prompts = [
    # 3 easy ones
    "List all ports that are contained by packet switch ju1.a1.m1.s2c1. Return a list.",
    "Add a new switch 'ju1.a1.m1.s3c9' on jupiter 1, aggregation block 1, domain 1, with 5 ports. You need to add an edge between new switch and existing topology at each layer. Return the new graph.",
    "Update the physical_capacity_bps from 1000 Mbps to 4000 Mbps on ju1.a1.m1.s2c2.p14. Convert Mbps to bps before the update. Return the new graph.",

    # 3 medium one
    "What is the bandwidth on ju1.a2.m1.s2c2? Note that first you need to list all port nodes that are contained by packet switch ju1.a2.m1.s2c2. Then sum the attribute physical_capacity_bps on the port nodes together. Output bandwidth unit should be in Mbps. Return only the number.",
    "What is the bandwidth on each AGG_BLOCK? Return a list. Note that AGG_BLOCK contains PACKET_SWITCH, PACKET_SWITCH contains PORT. Then sum the node attribute physical_capacity_bps on the port nodes together. Output bandwidth unit should be in Mbps. Return a table with header 'AGG_BLOCK', 'Bandwidth' on the first row.",
    "Find the first and the second largest Chassis by capacity on 'ju1.a1.m1'. Note that Chassis contains multiple PACKET_SWITCH from different spine block, PACKET_SWITCH contains PORT. Then sum the node attribute physical_capacity_bps on the port nodes together. Output bandwidth unit should be in Mbps. Return a table with header 'Chassis', 'Bandwidth' on the first row.",

    # 3 hard ones
    "Provide a graph that contains all SUPERBLOCK and AGG_BLOCK and plot their hierarchy. Return the new graph.",
    "Remove packet switch 'ju1.a1.m1.s2c4' out from Chassis c4, how to balance the capacity between Chassis? Note that Chassis contains multiple PACKET_SWITCH from different spine block, PACKET_SWITCH contains PORT. Then sum the node attribute physical_capacity_bps on the port nodes together. Return the balanced graph.",
    "Remove five ports from each packet switches ju1.a1.m1.s2c1, ju1.a1.m1.s2c2, ju1.a1.m1.s2c3, ju1.a1.m1.s2c4, ju1.a1.m1.s2c5. Make sure after the removal the capacity between switches is still balanced? Note that PACKET_SWITCH contains PORT. Capacity is the sum of node attribute physical_capacity_bps on the port nodes. Return the list of ports that will be moved."
]

answers=[
    # 3 easy ones
    "\ndef ground_truth_process_graph(graph_data):\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1.s2c1' and 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']:\n            target_node = node\n            break\n\n    if target_node is None:\n        return {'type': 'text', 'data': 'Packet switch not found'}\n\n    ports = []\n    for edge in graph_data.out_edges(target_node, data=True):\n        if edge[2]['type'] == 'RK_CONTAINS':\n            destination_node = edge[1]\n            if 'EK_PORT' in graph_data.nodes[destination_node]['type']:\n                ports.append(graph_data.nodes[destination_node]['name'])\n\n    return {'type': 'list', 'data': ports}",
    "\ndef ground_truth_process_graph(graph_data):\n    # Add the new switch node\n    new_switch = 'ju1.a1.m1.s4c7'\n    graph_data.add_node(new_switch, type=['EK_PACKET_SWITCH'])\n\n    # Add the new switch to the corresponding jupiter, aggregation block, domain, spineblock, and chassis\n    jupiter_node = 'ju1'\n    agg_block_node = 'ju1.a1'\n    domain_node = 'ju1.a1.m1'\n\n    graph_data.add_edge(jupiter_node, new_switch, type='RK_CONTAINS')\n    graph_data.add_edge(agg_block_node, new_switch, type='RK_CONTAINS')\n    graph_data.add_edge(domain_node, new_switch, type='RK_CONTAINS')\n\n    # Add the 5 ports to the new switch\n    for i in range(1, 6):\n        port_node = f'{new_switch}.p{i}'\n        graph_data.add_node(port_node, type=['EK_PORT'])\n        graph_data.add_edge(new_switch, port_node, type='RK_CONTAINS')\n\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Find the node with the specified name\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1.s2c2.p14':\n            target_node = node\n            break\n\n    # Update the physical_capacity_bps attribute\n    if target_node is not None:\n        graph_data.nodes[target_node]['physical_capacity_bps'] = 4000 * 1000000\n\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n\n    return return_object",

    # 3 medium ones
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Find the packet switch node\n    packet_switch_node = None\n    for node in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in node[1]['type'] and node[0] == 'ju1.a2.m1.s2c2':\n            packet_switch_node = node[0]\n            break\n\n    if packet_switch_node is None:\n        return {'type': 'text', 'data': 'Packet switch not found'}\n\n    # Find all port nodes contained by the packet switch\n    port_nodes = []\n    for edge in graph_data.edges(data=True):\n        if edge[2]['type'] == 'RK_CONTAINS' and edge[0] == packet_switch_node:\n            port_nodes.append(edge[1])\n\n    # Sum the physical_capacity_bps attribute on the port nodes\n    total_bandwidth_bps = 0\n    for port_node in port_nodes:\n        total_bandwidth_bps += graph_data.nodes[port_node]['physical_capacity_bps']\n\n    # Convert to Mbps\n    total_bandwidth_mbps = total_bandwidth_bps / 1e6\n\n    return {'type': 'text', 'data': str(total_bandwidth_mbps)}",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    agg_blocks = [node for node in graph_data.nodes if 'EK_AGG_BLOCK' in graph_data.nodes[node]['type']]\n    bandwidths = []\n\n    for agg_block in agg_blocks:\n        packet_switches = [node for node in graph_data.successors(agg_block) if 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']]\n        total_bandwidth = 0\n\n        for packet_switch in packet_switches:\n            ports = [node for node in graph_data.successors(packet_switch) if 'EK_PORT' in graph_data.nodes[node]['type']]\n\n            for port in ports:\n                total_bandwidth += graph_data.nodes[port]['physical_capacity_bps'] / 1e6  # Convert to Mbps\n\n        bandwidths.append([agg_block, total_bandwidth])\n\n    return_object = {\n        'type': 'table',\n        'data': [['AGG_BLOCK', 'Bandwidth']] + bandwidths\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Helper function to convert bps to Mbps\n    def bps_to_mbps(bps):\n        return bps / (10**6)\n\n    # Find the 'ju1.a1.m1' node\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1':\n            target_node = node\n            break\n\n    # Find all Chassis nodes\n    chassis_nodes = [n for n in graph_data.nodes if 'EK_CHASSIS' in graph_data.nodes[n]['type']]\n\n    # Calculate the total bandwidth for each Chassis\n    chassis_bandwidth = {}\n    for chassis in chassis_nodes:\n        bandwidth = 0\n        packet_switch_nodes = [n for n in graph_data.neighbors(chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n        for packet_switch in packet_switch_nodes:\n            port_nodes = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n            for port in port_nodes:\n                bandwidth += graph_data.nodes[port]['physical_capacity_bps']\n        chassis_bandwidth[chassis] = bps_to_mbps(bandwidth)\n\n    # Sort Chassis by bandwidth\n    sorted_chassis = sorted(chassis_bandwidth.items(), key=lambda x: x[1], reverse=True)\n\n    # Get the first and second largest Chassis\n    top_chassis = sorted_chassis[:2]\n\n    # Create the table\n    table = [['Chassis', 'Bandwidth']]\n    for chassis, bandwidth in top_chassis:\n        table.append([chassis, bandwidth])\n\n    return_object = {\n        'type': 'table',\n        'data': table\n    }\n\n    return return_object",

    # 3 hard ones
    "\ndef ground_truth_process_graph(graph_data):\n    subgraph_nodes = [node for node, attrs in graph_data.nodes(data=True) if 'EK_SUPERBLOCK' in attrs['type'] or 'EK_AGG_BLOCK' in attrs['type']]\n    subgraph_edges = [(src, dest) for src, dest, attrs in graph_data.edges(data=True) if attrs['type'] == 'RK_CONTAINS' and (src in subgraph_nodes or dest in subgraph_nodes)]\n    subgraph = graph_data.subgraph(subgraph_nodes).copy()\n    subgraph.add_edges_from(subgraph_edges)\n    \n    return_object = {\n        'type': 'graph',\n        'data': subgraph,\n    }\n    \n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Remove packet switch 'ju1.a1.m1.s2c4' from Chassis c4\n    packet_switch_to_remove = 'ju1.a1.m1.s2c4'\n    chassis_to_balance = 'c4'\n    if packet_switch_to_remove in graph_data.nodes():\n        graph_data.remove_node(packet_switch_to_remove)\n\n    # Find all Chassis nodes\n    chassis_nodes = [n for n, attr in graph_data.nodes(data=True) if 'EK_CHASSIS' in attr['type']]\n\n    # Calculate the total capacity for each Chassis\n    chassis_capacity = {}\n    for chassis in chassis_nodes:\n        packet_switches = [n for n in graph_data.neighbors(chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n        total_capacity = 0\n        for packet_switch in packet_switches:\n            ports = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n            for port in ports:\n                total_capacity += graph_data.nodes[port]['physical_capacity_bps']\n        chassis_capacity[chassis] = total_capacity\n\n    # Calculate the average capacity\n    average_capacity = sum(chassis_capacity.values()) / len(chassis_capacity)\n\n    # Balance the capacity between Chassis\n    for chassis in chassis_nodes:\n        if chassis_capacity[chassis] < average_capacity:\n            extra_capacity = average_capacity - chassis_capacity[chassis]\n            # Find a packet switch from another chassis with enough capacity\n            for other_chassis in chassis_nodes:\n                if other_chassis != chassis:\n                    other_packet_switches = [n for n in graph_data.neighbors(other_chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n                    for packet_switch in other_packet_switches:\n                        ports = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n                        packet_switch_capacity = sum(graph_data.nodes[port]['physical_capacity_bps'] for port in ports)\n                        if packet_switch_capacity >= extra_capacity:\n                            # Move the packet switch to the current chassis\n                            graph_data.remove_edge(other_chassis, packet_switch)\n                            graph_data.add_edge(chassis, packet_switch, type='RK_CONTAINS')\n                            break\n\n    return {'type': 'graph', 'data': graph_data}",
    "\ndef ground_truth_process_graph(graph_data):\n    packet_switches = ['ju1.a1.m1.s2c1', 'ju1.a1.m1.s2c2', 'ju1.a1.m1.s2c3', 'ju1.a1.m1.s2c4', 'ju1.a1.m1.s2c5']\n    removed_ports = []\n\n    for switch in packet_switches:\n        ports = [n for n in graph_data.neighbors(switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n        ports_capacity = {port: graph_data.nodes[port]['physical_capacity_bps'] for port in ports}\n        sorted_ports = sorted(ports_capacity.items(), key=lambda x: x[1], reverse=True)\n\n        for i in range(5):\n            removed_port = sorted_ports.pop(0)\n            removed_ports.append(removed_port[0])\n            graph_data.remove_node(removed_port[0])\n\n    return_object = {\n        'type': 'list',\n        'data': removed_ports\n    }\n\n    return return_object",
]

df['prompt'] = prompts
df['answer'] = answers


# Create the file path
file_path = os.path.join('../data/prompt_golden_ans.json')

allData = df.set_index('prompt').T.to_dict('records')[0]
with open(file_path, "w") as f:
    json.dump(allData, f)
